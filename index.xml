<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>b8u Blog</title>
    <link>https://b8u.github.io/</link>
    <description>Recent content on b8u Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ru</language>
    <lastBuildDate>Tue, 29 Oct 2019 20:01:32 +0100</lastBuildDate>
    
	<atom:link href="https://b8u.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Структура передачи последнего стейта потоку</title>
      <link>https://b8u.github.io/posts/concurent-last-state/</link>
      <pubDate>Tue, 29 Oct 2019 20:01:32 +0100</pubDate>
      
      <guid>https://b8u.github.io/posts/concurent-last-state/</guid>
      <description>Intro и постановка задачи Возникла у меня задача передавать данные между потоками со следующими условиями:
 Любой пакет не зависит от предыдущего. Новый пакет отменяет значение предыдущего. Пакет может быть сформирован лишь в определенный момент времени (не по запросу потребителя).  Другими словами есть некоторый снепшот состояния подсистемы, который уникален для каждого отрезка времени. Другой подсистеме нужно получать последнее доступное состояние (в любой момент времени). Решение получилось достаточно интересным, чем и решил поделиться с общественностью.</description>
    </item>
    
    <item>
      <title>Генерация обертки XMVector на шаблонах</title>
      <link>https://b8u.github.io/posts/xmvector-wrapper-generation-ru/</link>
      <pubDate>Mon, 05 Aug 2019 21:18:48 +0200</pubDate>
      
      <guid>https://b8u.github.io/posts/xmvector-wrapper-generation-ru/</guid>
      <description>Intro В библиотеке DirectXMath есть тип XMVector, который использует SIMD инструкции, для обеспечения большей производительности. Есть у него один недостаток - это упакованные данные и для получения привычного представления вектора (как скажем в glm), необходима конвертация через функции XMStore*/XMLoad*. Таких типов достаточно много и писать обертки к каждому дело утомительное, но можно поупражняться в шаблонах для автоматической генерации оберток.
Следует отметить, что использование кода ниже может привести к падению производительности вашего приложения.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://b8u.github.io/about/</link>
      <pubDate>Mon, 10 Jun 2019 15:00:37 +0200</pubDate>
      
      <guid>https://b8u.github.io/about/</guid>
      <description>TODO: Write something about myself.</description>
    </item>
    
    <item>
      <title>Рекурсивный шаблонный тип</title>
      <link>https://b8u.github.io/posts/template-recursion-type-ru/</link>
      <pubDate>Sun, 09 Jun 2019 16:01:23 +0800</pubDate>
      
      <guid>https://b8u.github.io/posts/template-recursion-type-ru/</guid>
      <description>Intro Довелось мне столкнуться со странной структурой данных (похожей на JSON). Она представляет собой гетерогенное дерево, каждый узел которого содержит некоторые данные и множество дочерних узлов. Особенность заключается в том, что это множество может быть как простым контейнером (std::vector) так и ассоциативным (std::map). Получается, если узел хранит дочерние узлы в мапе - это JSON Object, а если вектор - JSON Array.
В реализации этой структуры данных меня смущала сложная иерархия классов и то, что класс, который должен храниться в этом контейнере, обязательно должен реализовывать некий интерфейс.</description>
    </item>
    
  </channel>
</rss>